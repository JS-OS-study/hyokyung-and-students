# Lecture

---

- [운영체제 - 반효경 교수님](http://www.kocw.or.kr/home/cview.do?mty=p&kemId=1046323)
  - Memory Management 1
  - Memory Management 2

<br />

# Memory

---

각 프로세스는 독립적인 메모리를 점유한다 하였다.

이번에는 운영체제가 메모리를 어떻게 관리하는지 알아 볼 것이다.

<br />

## Logical Address vs Physical Address

---

![image](https://user-images.githubusercontent.com/71188307/156889420-a02b0b51-2254-48a6-a06b-26faa8315555.png)

<br />

### Address Binding

---

프로세스의 논리적 주소를 물리적 메모리 주소로 연결하는 작업을 말한다.

> Symbolic Address -> `Logical Address (바로 이 시점)` -> Physical Address 

Symbolic Address는 프로그래머 입장에서 사용하는 것이며, 프로그래머는 데이터를 메모리 몇 번지에 저장하라고 코딩하지 않고, 문자로 된 변수명을 사용한다.

마찬가지로, 함수도 메모리 몇 번지로 jump하라고 코딩하지 않고, 문자로 된 함수명을 사용한다.

이를 Symbolic하다고 표현하며, 주소 바인딩 방식은 프로그램이 적재되는 물리적 메모리의 주소가 결정되는 시기에 따라 세 가지로 분류할 수 있다.

<br />

![image](https://user-images.githubusercontent.com/71188307/156890004-1ab854de-9a36-414b-93d4-25b9f785f41a.png)

<br />

- `Compile Time Binding`
  - 프로그램을 컴파일할 때 물리적 메모리 주소가 결정되는 주소 바인딩 방식
  - 컴파일 하는 시점에 해당 프로그램이 물리적 메모리의 몇 번지에 위치할 것인지를 이미 결정하므로 프로그램이 절대 주소로 적재된다는 뜻에서 절대 코드를 생성하는 바인딩 방식이라고도 부른다
  - 프로그램이 올라가 있는 물리적 메모리의 위치를 변경하고 싶다면 컴파일을 다시 해야 한다
  - 멀티프로그래밍이 없던 시절에는 사용됐으나, 현대의 시분할 컴퓨팅 환경에서 거의 사용하지 않는다

<br />

- `Load Time Binding`
  - 프로그램이 실행 될 때 물리적 메모리 주소가 결정되는 주소 바인딩 방식
  - Loader의 관리 하에 물리적 메모리 주소가 결정되며 프로그램이 종료될 때까지 물리적 메모리 상의 위치가 고정된다
    - Loader는 사용자 프로그램을 메모리에 적재하는 프로그램이다
  - 컴파일러가 재배치 가능 코드를 생성한 경우에만 가능하다

<br />

- `Execution Time Binding` or `Runtime Binding`
  - 프로그램이 실행된 후에도 프로그램이 위치한 물리적 메모리 주소가 변경 될 수 있는 바인딩 방식
  - CPU가 주소를 참조할 때마다 해당 데이터가 어느 물리주소에 위치에 존재하는지 확인해야하는데, 이때 `MMU(Memory Management Unit)`의 주소 매핑 테이블을 사용한다
    - MMU는 논리적 주소와 물리적 주소를 매핑해주는 하드웨어 장치이다 (데이터베이스 매핑 테이블을 연상하라)
  - MMU, 기준 레지스터, 한계 레지스터 등과 같은 하드웨어적인 자원이 필요하다
  - 현대의 시분할 컴퓨팅 환경에서 사용되는 방식

<br />

## MMU(Memory Management Unit)

---

![image](https://user-images.githubusercontent.com/71188307/156890264-594e4195-8654-4687-842b-a4188f4ed6ba.png)

<br />

![image](https://user-images.githubusercontent.com/71188307/156890486-86575be0-1ade-4bf1-a1de-3316ab261786.png)

<br />

- Relocation Register (Base Register)
  - 사용자 프로세스의 논리적 주소 0번지에 매핑된 물리적 주소를 의미
  - 사용자 프로세스는 항상 자신의 시작 주소가 0번지라고 생각하지만, 이는 논리 주소일 뿐이며, 실제 물리 주소는 0번지가 아닐 수 있다
  - 위 그림에서 P1은 CPU를 통해 논리 주소 346번지의 데이터를 요청했으나, 실제로 이 사용자 프로세스가 할당받은 물리 시작 주소는 14,000번지로 MMU에 저장돼있으므로 MMU는 14,000에 346을 더한 14,346번지의 주소를 반환한다
- Limit Register
  - 사용자 프로세스에게 할당된 메모리의 최대 크기를 저장하는 레지스터
  - 운영체제가 사용자 프로세스에게 할당한 메모리를 넘어 바깥의 메모리를 침범하면, 이 프로세스는 악의적인 프로세스(바이러스 등)일 가능성이 있으므로 이를 차단해야 한다
  - 위 그림에서 운영체제가 P1에게 할당한 메모리의 크기는 3,000이며, 물리 주소는 14,000~17,000 이다

<br />

![image](https://user-images.githubusercontent.com/71188307/156890581-fd4ac610-ee81-440d-9f3f-a03355577dfd.png)

<br />

## Memory Terminology

### Dynamic Loading

---

- 프로세스 전체를 메모리에 미리 다 올리는 것이 아니라 해당 루틴이 불려질 때 메모리에 올리는 것
- 메모리를 더 효율적으로 사용할 수 있게 된다
- 가끔씩 사용되는 많은 양의 코드의 경우, 예를 들자면 오류 처리 루틴같은 것들에 유용하다
- 운영체제의 특별한 지원 없이 프로그램 자체에서 구현이 가능하며, 운영체제가 라이브러리를 통해 지원할 수도 있다

<br />

### Overlay

---

- 메모리에 프로세스의 부분 중 실제 필요한 정보만을 올리는 기법으로 Dynamic Loading와 비슷하여 헷갈릴 수 있다
- 초창기 컴퓨터 시스템은 메모리가 매우 작아 하나의 프로세스조차도 메모리에 한꺼번에 올릴 수 없었다
- 프로세스의 주소 공간을 분할해 당장 필요한 부분만을 메모리에 올려 실행하고 해당 부분에 대한 실행이 끝난 후에 나머지 부분을 올려 실행하는 기법
- 프로세스의 크기가 메모리보다 클 때 유용하다
- 작은 공간의 메모리를 사용하던 초창기 시스템에서 운영체제의 지원 없이 수작업으로 프로그래머가 구현하였다. 즉, 현재는 일반적으로 사용되지 않는다
  - 프로그래밍이 상당히 복잡하다.
- Dynamic Loading과의 차이점
  - Dynamic Loading: 멀티프로그래밍 환경에서 메모리에 더 많은 프로세스를 동시에 올려놓고 실행하기 위한 용도. 운영체제의 도움을 받는다
  - Overlay: 단일 프로세스만을 메모리에 올려놓는 환경에서 메모리 용량보다 큰 프로세스를 올리기 위한 용도. 운영체제의 도움을 받지 않는다

<br />

### Swapping

---

- 메모리에 올라온 프로세스를 디스크의 Backing Store로 쫓아내는 것
  - Backing Store는 Swap Area라고도 부르며, 디스크 내에 파일 시스템과는 별도로 존재하는, 많은 사용자 프로세스를 담을 만큼 충분히 빠르고 큰 저장 공간이다
- 디스크에서 메모리로 올리는 작업을 Swap In, 메모리에서 디스크로 내리는 작업을 Swap Out라고 부른다
- Swap이 일어나는 과정
  - 일반적으로 중기 스케줄러(Swapper)가 Swap Out할 프로세스를 선정한다
    - 주로 우선 순위 기반 CPU 스케줄링을 사용한다
    - 우선 순위가 높은 프로세스를 Swap In
    - 우선 순위가 낮은 프로세스를 Swap Out
  - 만약 컴파일 타임 바인딩 혹은 로드 타임 바인딩 방식이 사용되고 있다면, Swap Out되었다가 Swap In이 되면 원래 존재하던 메모리 위치로 다시 올라가야만 한다
  - 반면 런타임 바인딩 방식이 사용되고 있다면, 추후 빈 메모리 영역 아무 곳에나 프로세스를 올릴 수 있으므로 Swapping에 적합하다
- Swap Time은 디스크의 탐색 시간이나 회전 지연 시간 보다는 디스크 섹터에서 실제 데이터를 읽고 쓰는 전송 시간(transfer time)이 대부분을 차지한다
  - 디스크는 물리적으로 움직이는 시간이 존재하기 때문에, 전기적 신호로 동작하는 메모리에 비해 심각하게 느리다

---

### Dynamic Linking

---

- 연결(Linking)이란, 개발자가 작성한 소스 코드를 컴파일하여 생성된 목적 파일(object file)과 이미 컴파일된 라이브러리 파일들을 묶어 하나의 실행 파일을 생성하는 과정이다
- Dynamic Linking은 컴파일을 통해 생성된 목적 파일과 라이브러리 파일 사이의 연결을 프로그램의 실행 시점까지 지연하는 기법이다.
- Static Linking
  - 외부 라이브러리가 프로그램의 실행 파일에 포함된다
  - 실행 파일의 크기가 커진다
  - 동일한 라이브러리를 각각의 프로세스가 메모리에 올리므로 메모리 낭비가 심하다
- Dynamic Linking
  - 실행 파일에 라이브러리 코드가 포함되지 않으며, 프로그램이 실행되면서 라이브러리 함수를 호출할 때가 되어서야 라이브러리에 대한 연결이 이루어진다
  - 라이브러리 호출 부분에 라이브러리 루틴의 위치를 찾기 위한 Stub이라는 작은 코드를 둔다
  - 라이브러리가 이미 메모리에 있으면 그 루틴의 주소로 가고, 없으면 디스크에서 읽어 온다
  - 운영 체제의 도움이 필요하다

<br />

## Allocation Of Physical Memory

---

- 물리적 메모리는 운영체제 상주 영역(커널)과 사용자 프로세스 영역으로 나뉨
  - 운영체제 상주 영역은 인터럽트 벡터와 함께 낮은 주소 영역을 사용한다 (주로 물리적 메모리의 0번지)
  - 사용자 프로세스 영역은 운영체제보다 높은 주소 영역을 사용

<br />

### Contiguous Allocation

---

- 각각의 프로세스가 연속적인 메모리 공간에 적재되도록 하는 것
- 고정 메모리 분할 방식과 가변 메모리 분할 방식이 존재
- 고정 분할 방식은 외부 조각과 내부 조각이 동시에, 가변 분할 방식은 외부조각이 발생할 수 있다
  - 외부 조각 (External Fragmentation)
    - 프로그램의 크기보다 파티션의 크기가 작은 경우 해당 파티션이 비어있는 데도 불구하고 프로그램을 적재하지 못하기 때문에 생기는 메모리 공간을 의미
  - 내부 조각 (Internal Fragmentation)
    - 프로그램의 크기보다 파티션의 크기가 큰 경우 해당 파티션에 프로그램을 적재하고 남는 메모리 공간을 의미

<br />

![image](https://user-images.githubusercontent.com/71188307/156916189-a3c38169-c2be-424e-9ab8-f39806943148.png)

<br />

![image](https://user-images.githubusercontent.com/71188307/156916195-5fa84be8-d7d9-467b-ba0b-9674a7ecfc04.png)

<br />

![image](https://user-images.githubusercontent.com/71188307/156916501-b54f0f76-a504-4311-84f2-02c258d1e19a.png)

<br />

#### Dynamic Storage Allocation Problem

---

- 가변 분할 방식에서 주소 공간의 크기가 n인 프로세스를 메모리에 올릴 때 물리적 메모리 내의 가용 공간 중 어느 위치에 올릴 것인지 결정하는 문제
- First-fit
  - size가 n 이상인 것 중 최초로 찾아지는 hole에 할당
- Best-fit
  - size가 n 이상인 가장 작은 hole을 찾아 할당
  - hole 리스트가 크기 순으로 정렬되지 않은 경우 모든 hole을 탐색해야 함
  - 많은 수의 아주 작은 hole이 생성 됨
- Worst-fit
  - 가장 큰 hole에 할당 해야 함
  - 역시 hole을 탐색해야 함
  - 상대적으로 아주 큰 hole이 생성 됨
- First-fit과 Best-fit이 Worst-fit보다 속도와 공간 이용률 측면에서 효과적

<br />

#### Compaction

---

- 외부 조각 문제를 해결하는 방법 중 하나
- 물리적 메모리 중에서 프로세스에 의해 사용 중인 메모리를 한 쪽으로 밀고, 가용 공간들을 다른 한쪽으로 몰아서 하나의 큰 가용 공간을 만드는 방법이다 (디스크 조각모음?, 가비지 컬렉션?)
- 매우 비용이 많이 드는 방법이다
- 최소한의 메모리 이동으로 압축하는 방법은 매우 복잡한 문제이다
- 압축은 프로세스의 주소가 실행 시간에 동적으로 재배치가 가능한 런타임 바인딩 방식을 지원하는 환경에만 가능하다

<br />

### Non-Contiguous Allocation

---

- 하나의 프로세스가 메모리의 여러 영역에 분산되어 적재 되는 것
- Paging, Segmentation, Paged Segmentation 방식이 존재
- 현대의 컴퓨팅 시스템은 Non-Contiguous Allocation 방식의 Paging 기법을 주로 사용한다

<br />

#### Paging

---

- 프로세스의 주소 공간을 동일한 크기의 페이지 단위로 나누어 메모리의 서로 다른 위치에 페이지를 저장하는 방식
- 각 프로세스의 주소 공간 전체를 메모리에 한꺼번에 올릴 필요가 없고, 일부는 Backing Storage, 일부는 메모리에 혼재하는 것이 가능해진다
- 메모리를 페이지와 같은 동일한 크기의 프레임으로 미리 나누어 둔다. 이를 `페이지 프레임(Page Frame)` 이라 칭한다
- 메모리에 올리는 단위가 동일한 크기의 페이지 단위이므로 외부 조각이 발생하지 않고, 동적 메모리 할당 문제도 고려할 필요가 없어진다
- 주소 매핑을 기존 MMU의 레지스터 두개로는 처리할 수 없고, 페이지 테이블이라는 것을 사용하여 논리적 주소를 물리적 주소로 변환하는 작업이 필요해진다
- 프로그램의 크기가 항상 페이지 크기의 배수가 된다는 보장이 없으므로 프로세스의 주소 공간 중 제일 마지막에 위치한 페이지에서는 내부 조각이 발생할 수 있다

<br />