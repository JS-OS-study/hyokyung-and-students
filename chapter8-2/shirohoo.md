# Lecture

---

- [운영체제 - 반효경 교수님](http://www.kocw.or.kr/home/cview.do?mty=p&kemId=1046323)
  - Memory Management 3
  - Memory Management 4

<br />

# Paging

---

## Multilevel Paging and Performance

---

- 프로세스의 주소 공간이 커질수록 페이지 테이블의 크기도 커지므로 주소 변환을 위한 메모리 공간 낭비가 심해진다
- 이 때, 다단계 페이지 테이블을 사용하면 페이지 테이블을 위해 사용되는 메모리 공간의 소모를 줄일 수 있지만, 메모리 접근 시간이 늘어난다
- 이 문제를 다시 TLB를 통해 메모리 접근 시간을 줄일 수 있다. 즉 현대의 컴퓨팅 시스템에서 TLB는 필연이다
- 4단계 페이지 테이블을 사용하는 경우
  - 메모리 접근 시간 = 100ns, TLB 접근 시간 = 20ns
  - 요청된 페이지에 대한 주소 변환 정보가 TLB에 존재할 확률 98%
  - 평균 메모리 접근 시간 (EAT) = 0.98 x 120 + 0.02 x 520 = 128ns
    - TLB hit이 성공할 때 - TLB 접근 시간과 메모리 접근 시간의 합인 120ns
    - TLB hit이 실패할 때 - TLB 접근 시간과 메모리 접근 시간 x 5의 합인 520ns
  - 결과적으로 주소 변환을 위해서만 28ns가 소요됨

<br />

## Memory Protection

---

- 페이지 테이블의 각 항목에는 주소 변환 정보 외에 메모리 보호를 위한 보호 비트와 `유효-무효 비트(Valid (v) / Invalid (i))`가 존재
- 보호 비트는 각 페이지에 대해 읽기-쓰기/읽기 전용 등의 접근 권한을 설정하는 데 사용
- 유효-무효 비트는 해당 페이지의 내용이 유효한지에 대한 내용을 포함
  - 유효-무효 비트가 `유효` 인 경우 - 해당 메모리 프레임에 해당 페이지가 존재. 따라서 접근 허용
  - 유효-무효 비트가 `무효` 인 경우 - 해당 페이지가 물리적 메모리에 올라와 있지 않고, Backing Store에 존재하여 해당 메모리 프레임에 접근 불가

![image](https://user-images.githubusercontent.com/71188307/157247187-d39a800b-b6e9-4b16-81d0-1588e3a5442f.png)

<br />

## Inverted Page Table

---

![image](https://user-images.githubusercontent.com/71188307/157246743-5d8f7afb-1854-4f64-8967-adf41c50524d.png)

![image](https://user-images.githubusercontent.com/71188307/157245564-3ebf3ee6-f79e-4dad-9f2a-37bb07d05446.png)

<br />

## Shared Page

---

- `공유 코드(Shared Code)`는 메모리 공간의 효율적인 사용을 위해 여러 프로세스가 공통적으로 사용 할  수 있도록 작성된 코드를 의미
  - 재진입 가능 코드, 순수 코드라고도 불리며, `읽기 전용(Read Only)`의 특성을 가짐
- `공유 페이지(Shared Page)`는 공유 코드를 담고 있는 페이지를 의미
  - 공유 페이지는 여러 프로세스에게 공유되는 페이지이므로 물리적 메모리에 하나만 적재되어 메모리를 효율적으로 사용할 수 있음
- 예를 들어 문서 편집기 프로그램을 공유 페이지를 사용해서 작성한 경우, 이 프로세스를 여러 개 수행하더라도 공유 코드를 담은 페이지는 메모리에 하나만 올라감
  - 공유 코드는 읽기 전용의 성질을 가져야 하고 모든 프로세스의 논리적 주소 공간에서 동일한 위치에 존재해야 한다
- 사유 페이지는 프로세스들이 공유하지 않고, 프로세스 별로 독자적으로 사용하는 페이지를 의미
  - 사유 페이지는 해당 프로세스의 논리적 주소 공간 중 어떠한 위치에 있어도 무방
- `ed1`, `ed2`, `ed3`은 공유 페이지, `data1`, `data2`, `data3`은 사유 페이지

<br />

![image](https://user-images.githubusercontent.com/71188307/157245569-12fb4e81-4df5-4282-b1e5-2d96244ffabf.png)

<br />

# Segmentation

---

- 프로그램은 의미 단위인 여러 개의 세그먼테이션으로 구성
  - 작게는 프로그램을 구성하는 하나 하나를 세그먼트로 정의
  - 크게는 프로그램 전체를 하나의 세그먼트로 정의 가능
  - 일반적으로는 `code`, `data`, `stack` 부분이 각각 하나의 세그먼트로 정의됨
- 세그먼트는 다음과 같은 logical unit들임
  - main()
  - function
  - global variables
  - stack
  - symbol table
  - arrays

<br />

## Segmentation Architecture

---

- 논리 주소는 `<세그먼트 번호(s), 오프셋(d)>` 두 가지로 구성됨
  - s는 해당 논리 주소가 프로세스 주소 공간 내에서 몇 번째 세그먼트에 속하는지를 나타냄
  - d는 세그먼트 내에서 얼마만큼 떨어져 있는 지에 대한 정보를 나타냄
- 세그먼트 테이블 사용
  - 기준점(base)과 한계점(limit)을 가진다
  - 기준점은 물리 메모리에서 그 세그먼트의 시작 위치를 나타낸다
  - 한계점은 물리 메모리에서 그 세그먼트의 길이를 나타낸다
- 세그먼트 테이블 기준 레지스터(STBR)와 세그먼트 테이블 길이 레지스터(STLR)을 사용
  - STBR은 현재 CPU에서 실행 중인 프로세스의 세그먼트 테이블이 메모리의 어느 위치에 있는지 그 시작 주소를 담고 있다
  - STLR은 그 프로세스의 주소 공간이 총 몇 개의 세그먼트로 구성되는지, 즉 세그먼트의 개수를 나타낸다

<br />

## Segmentation Hardware

---

![image](https://user-images.githubusercontent.com/71188307/157245591-7e0bee50-3280-4044-a4c3-8a374dc51a34.png)

<br />

- 논리적 주소를 물리적 주소로 변환하기 전에 두 가지 사항을 확인
  - 요청된 세그먼트 번호(s)가 STLR에 저장된 값보다 작은 값 인지?
    - 아니라면, 존재하지 않는 세그먼트에 대한 접근 시도이므로 예외 발생
  - 논리적 주소의 오프셋(d)이 그 세그먼트의 길이(limit)보다 작은 값 인지?
    - 아니라면, 세그먼트 길이를 넘어서는 오프셋 위치이므로 예외 발생

<br />

### Protection

---

- 각 세그먼트별로 `보호 비트(Protection Bit)`가 있다
  - 보호 비트는 각 세그먼트에 대해 읽기/쓰기/실행 등의 권한이 있는지를 의미
- 각 세그먼트 별로 `유효 비트(Valid Bit)`가 있다
  - 유효 비트는 각 세그먼트의 주소 변환 정보가 유효한지를 의미
  - 즉, 해당 세그먼트가 현재 물리 메모리에 적재되어 있는지를 의미

<br />

### Sharing

---

- 여러 프로세스가 특정 세그먼트를 공유하여 사용하는 개념
- 공유 세그먼트는 이 세그먼트를 공유하는 모든 프로세스의 주소 공간에서 동일한 논리적 주소에 위치해야 함

<br />

![image](https://user-images.githubusercontent.com/71188307/157245601-d6d6dfe8-4a44-44a1-af49-061fb63fa0ef.png)

<br />

---

### Allocation of Physical Memory

---

![image](https://user-images.githubusercontent.com/71188307/157251244-dcc3a8dd-230c-47eb-9814-a62ae0d715f5.png)

<br />

## Advantages and Disadvantages of Segmentation

---

- Advantages
  - 주소 공간의 일부를 공유하거나 특정 주소 공간에 읽기 전용 등의 접근 권한 제어를 하고자 할 경우, 이는 단순히 크기 단위가 아닌 어떤 의미 단위로 이루어질 때가 많음
  - 이 때, 세그먼트는 의미 단위로 나누어져 있기 때문에 공유와 보안의 측면에서 페이징 기법에 비해 훨씬 효과적

<br />

- Disadvantages
  - 세그먼테이션 기법에서는 프로그램을 의미 단위로 나누기 때문에 세그먼트의 길이가 균일하지 않음
  - 메모리 관리에서 외부 단편화가 발생하게 되며, 연속 할당 메모리 관리의 가변 분할 방식에서의 동일한 문제점이 발생

<br />

# Paged Segmentation

---

![image](https://user-images.githubusercontent.com/71188307/157245607-0fbccdb1-fb87-4aea-942a-b41ca5cd5fb9.png)

- 페이지드 세그먼테이션 기법은 프로그램을 의미 단위의 세그먼트로 나누되, 세그먼트가 동일한 크기 페이지의 집합으로 구성 됨
  - 페이지드 세그먼테이션 기법에서는 하나의 세그먼트 크기를 페이지 크기의 배수가 되도록 함으로써 세그먼테이션 기법에서 발생하는 외부 조각의 문제를 해결
  - 세그먼트 단위로 프로세스 간의 공유나 프로세스 내의 접근 권한 보호가 이루어지도록 함으로써 페이징 기법의 문제를 해결
- 주소 변환을 위해 외부의 세그먼트 테이블과 내부의 페이지 테이블, 이렇게 두 단계의 테이블을 이용
  - 하나의 세그먼트가 여러 개의 페이지로 구성되므로 각 세그먼트마다 페이지 테이블을 가지게 됨
  - 즉, 2단계 페이지 테이블과 유사한 구조
- <세그먼트 번호(s), 오프셋(d)>으로 구성된 논리 주소를 물리 주소로 변환하는 과정
  - 논리 주소의 상위 비트인 s를 통해 세그먼트 테이블의 해당 항목에 접근
    - 이 세그먼트 항목에는 세그먼트 길이와 그 세그먼트의 페이지 테이블 시작 주소가 포함된다
  - d를 세그먼트 내에서의 페이지 번호(p), 페이지 내에서의 변위(d')로 사용하도록 분리
  - p와 d'를 이용하여 물리 메모리에 접근
  
<br />
