# System Structure & Program Execution

이번 챕터는 머릿속에 운영체제의 전체적인 그림을 그리기 위한 챕터로 본 운영체제 강의에서 가장 어려운 부분 중 하나라고 할 수 있다.

![image](https://user-images.githubusercontent.com/71188307/152781815-721cbda4-a97b-41a0-a0dc-852cde73e3db.png)

## CPU

CPU는 명령어의 인출, 실행을 담당하며, 매 클럭당 `프로그램 카운터(PC)`가 가르키는 메모리 주소에 위치한 `명령어(instruction)`를 `메모리 컨트롤러(Memory Controller)`를 통해 인출하고, 인출 된 명령어를 처리(=연산)한 후 결과를 다시 메모리 컨트롤러에게 알려준다.

또한 CPU는 매번 하나의 명령어를 처리한 후 인터럽트 라인을 체크하여 인터럽트가 있다면 `커널 모드`(Mode bit=0)로 변경하여 CPU의 제어권을 운영체제로 넘긴다. 

## Operating System

운영체제도 하나의 프로세스로서 메모리에 올라가며, 컴퓨터에 전원이 인가돼있는 동안 항상 메모리에 상주해야만 하는 중요한 부분(코드들)을 좁은 의미로서의 `커널(Kernel)`이라고 부른다. 그리고 이 좁은 의미의 커널이 일반적으로 컴퓨터 과학 전공에서 말하는 운영체제이기도 하다.

운영체제는 어떻게 해야 컴퓨터의 하드웨어 리소스를 가장 효율적으로 사용할 수 있는가를 제 1목적으로 동작한다.

예를 들어 중요한 프로세스가 CPU를 더 많이 점유하고, 상대적으로 덜 중요한 프로세스가 CPU를 더 적게 점유하도록 하는 CPU 스케쥴링(엘리베이터를 연상하자), 실행되는 프로세스들이 메모리의 단편화를 최대한 적게 발생할 수 있게끔 하는 메모리 관리(조각 모음을 연상하자) 등을 담당한다.

또한, 인터럽트 발생 시 해당 인터럽트가 정확히 어떤 요인에 의해 발생한 인터럽트인지를 파악하고 CPU에게 적절한 처리를 지시해주는 `인터럽트 서비스 루틴(ISR, Interrupt Service Routine)`을 제공한다.

## Memory Controller

저장장치에는 물리적으로 임의의 공간에 임의의 자료가 들어있을 뿐이며, 저장장치 스스로 데이터를 읽고 쓸 수 없다. 

이러한 자료를 읽고 쓰기 위해서는 저장장치의 구조에 대해 알고 있으면서도 CPU의 요구사항도 이해할 수 있는 추상화 계층이 필요한데, 이 계층에 속하는 하드웨어가 메모리 컨트롤러이다.

기본적으로 메모리 컨트롤러는 메모리에 대한 전반적인 관리를 담당하며, 부가적으로 CPU의 요구사항에 맞춰 메모리를 조작하는 역할도 한다.

- 메모리가 동작할 수 있게 적당한 전압을 인가한다
- 휘발성인 메인 메모리의 데이터가 사라지지 않도록 주기적으로 refresh 한다
- 메모리에 올라와있는 프로그램의 명령어를 CPU로 인출해준다
- CPU가 메모리에 데이터 쓰기 요청을 해오면 해당 요청을 받아 메모리에 데이터를 저장한다

이를 카페에 비유하자면, 카페에는 계속해서 커피만 내리는 커피머신이 있을 것인데 이 커피머신이 CPU이며, 고객의 요청을 받아 처리하는 직원이 메모리 컨트롤러라고 볼 수 있고, 직원에게 요청을 하는 고객이 메모리에 올라와있는 프로그램이라고 볼 수 있겠다.

메모리는 메모리 컨트롤러에 종속적이기 때문에 메모리의 성능이 아무리 좋더라도, 메모리 컨트롤러의 처리속도가 따라주지 못한다면 메모리의 성능을 온전히 다 사용할 수 없다.

## Mode bit

현재 CPU를 사용하고 있는 프로세스의 권한을 의미하며, 0이라면 커널 모드, 1이라면 사용자 모드이다.

커널 모드라는 것은 CPU를 운영체제가 제어하고 있다는 의미이며, 커널 모드일 경우 컴퓨터의 모든곳에 접근할 수 있다. (즉, 관리자 권한)

사용자 모드라는 것은 CPU를 운영체제가 아닌 다른 프로세스(사용자 프로세스)가 점유하고 있다는 의미이며, 이 경우 CPU는 사용자 프로세스가 위치한 메모리 공간만 접근할 수 있다.

기본적으로 사용자 프로세스는 믿을 수 없기 때문에(악성 프로그램 등) 보안을 위한 조치이다.

## DMA(Direct Memory Access) Controller

모든 I/O 장치들이 CPU에 직접적으로 인터럽트를 걸어대면 CPU가 자주 방해받아 오버헤드가 커지기 때문에 DMA 컨트롤러가 I/O 장치들의 인터럽트를 받고 데이터를 메모리에 읽고쓴다음(메모리 컨트롤러에 요청), CPU에 인터럽트를 한번 발생시킨다.

즉, 일종의 일괄배치 시스템으로, 비유하자면 삽질을 한번 할때마다 흙을 삽에 올려둔채로 왔다갔다 하면 체력적인 비용이 크게 발생한다.

반대로 삽질을 해서 흙을 퍼올려 수레에 쌓아둔 후 수레를 끌고 한번만 다녀오면 체력적인 비용이 크게 감소된다.

## Timer

우리가 사용하는 컴퓨터는 동시에 여러개의 프로그램이 실행되는 것처럼 보인다. (인터랙션)

하지만, 실제로는 CPU는 동시간대에 정확히 하나의 일만을 하고있으며, 단지 이 일을 수시로 바꿔가면서 하고 있을 뿐이다.

![image](https://user-images.githubusercontent.com/71188307/147462440-ad1aacc3-6b98-41aa-937a-9df5b45f24f1.png)

<br />

예를 들어 커다란 담벼락을 3분할하여 각각 `빨간색`, `초록색`, `파란색` 페인트를 칠해야한다고 가정해보자.

이때 가장 효율적인 방법은 빨간색 페인트를 쭉 칠하고, 페인트를 초록색으로 바꾼다.

이후 초록색을 쭉 칠하고 페인트를 파란색으로 바꾼다.

이렇게 하면 페인트를 단 두번만 교체하면 된다.

그리고 여기서 페인트를 교체하는 작업이 바로 컴퓨터과학에서 말하는 `컨텍스트 스위칭(Context Switching)`이라고 볼 수 있겠다.

<br />

![image](https://user-images.githubusercontent.com/71188307/147462586-b94821b0-4cea-4b17-9ecf-ee02f99115df.png)

<br />

![image](https://user-images.githubusercontent.com/71188307/147462664-0e9f70a6-0022-42e0-b0fe-87c38088364e.png)

<br />

![image](https://user-images.githubusercontent.com/71188307/147462724-f5582960-147b-44c0-a04d-182c6f84c583.png)

<br />

하지만 위와 같이 처리 할 경우 한가지 문제가 있다.

페인트를 교체하는 비용은 적지만, 빨간색이 다 칠해지기 전까지는 초록색과 파란색 벽면을 빠르게 볼 수 없다.

그리고 파란색은 빨간색과 초록색이 모두 칠해지기 전까지 볼 수 없다.

이를 대입해 생각하면 예를 들어 키보드를 입력했는데 입력한 값이 10초 후에 화면에 표시되는 상황을 상상할 수 있다. 즉, 사용자 경험이 크게 나빠진다.

이러한 문제를 해결하기 위해 다음과 같은 방식을 사용한다.

1. 빨간색을 조금 칠한 후 페인트를 초록색으로 바꾼다.
2. 초록색을 조금 칠한 후 페인트를 파란색으로 바꾼다.
3. 파란색을 조금 칠한 후 페인트를 빨간색으로 바꾼다.
4. 1~3을 반복한다.

<br />

![image](https://user-images.githubusercontent.com/71188307/147463597-b4271b87-8ea7-4c63-95d1-669de7ac1d50.png)

<br />

![image](https://user-images.githubusercontent.com/71188307/147463758-0af6d74a-eef2-4b46-9ed0-6aec4815dd6d.png)

<br />

...

<br />

![image](https://user-images.githubusercontent.com/71188307/147463965-7847d7e5-1e64-4fe7-9e07-8102287437b4.png)

<br />

처음에는 페인트 교체를 단 2번만 해서 벽을 모두 칠했는데, 여기서는 벽을 조금 칠하고 페인트를 바꿔서 다른 벽을 칠하는 식으로 모든 벽을 동시에 칠했다.

그래서 페인트를 14번이나 교체하고서야 벽을 다 칠할수 있었다.

이러한 방식을 `시분할(Time sharing)`이라 하며, 페인트를 교체하는 작업을 컴퓨터 과학에서는 `컨텍스트 스위칭(Context Switching)`이라고 볼 수 있다.

CPU는 사용자 경험 증대(인터랙션)를 위해 매번 하는 작업을 변경해야 하는데, CPU가 작업을 매번 바꿀경우 이전에 한 작업을 이어서 해야 하기 때문에 이전에 한 작업을 모두 기억해야 한다.

때문에 이를 프로세스에 위치한 `PCB(Program Controll Block)`에 저장하고 레지스터를 초기화한다. 그리고 이를 컨텍스트 스위칭이라고 부른다.

운영체제는 이 시분할 시스템을 위해 사용자 프로세스에게 CPU를 점유할 수 있는 시간을 할당(CPU 스케쥴링)하는데, 사용자 프로세스가 무한 루프등의 이유로 CPU를 반환하지 않고 계속 점유하는것을 방지하기 위해 타이머를 사용한다. 

사용자 프로세스가 CPU를 점유한 시간이 타이머에 지정된 시간을 넘길 경우 운영체제는 사용자 프로세스에게서 CPU를 강제로 회수한다.

## Device Controller

I/O 디바이스를 제어하는 작은 CPU라고 볼 수 있으며, CPU와 I/O 디바이스 간의 모든 처리는 이 디바이스 컨트롤러가 담당한다.

## Local Buffer

I/O 디바이스에게 주어진 작은 저장장치이다. 예를 들어 키보드를 입력하면 입력한 키의 코드값이 키보드 버퍼에 담기고, 디바이스 컨트롤러가 키보드 버퍼에 쌓인 데이터들을 인터럽트와 함께 CPU를 향해 보낸다. (실제로는 DMA 컨트롤러가 받아 처리할 것으로 예상된다)

## I/O 수행

모든 I/O 명령은 커널 모드로만 가능하다. 그렇다면 사용자 프로그램은 어떻게 I/O 작업을 할 수 있을까? 바로, `시스템 콜(System Call)`을 활용한다.

시스템 콜은 사용자 프로세스가 운영 체제에게 작업을 대신 처리해줄 것을 요청하는 것을 말한다. 즉, 운영 체제에 정의된 함수를 간접적으로 호출하는 것이라고 생각하면 된다.

Mode bit가 1인 상태(사용자 모드)로 프로세스가 실행되고 있다가 I/O 작업을 해야 하는 상황이 오면 바로 운영체제의 메모리 주소로 접근 할 수 없다. 

그래서 프로그램이 직접 인터럽트를 발생시켜 버리면, CPU는 사용자 프로세스의 명령어를 하나 처리한 후 인터럽트를 체크할 것이다. 그리고 CPU는 사용자 프로세스가 발생시킨 인터럽트를 확인하게 되어 다음 명령어를 수행하는 대신 하던 작업을 저장하고 Mode bit를 0으로(커널 모드) 변경한 후 제어권을 운영체제에 넘기게 된다.

그리고 인터럽트에 의해 CPU 제어권을 넘겨받게 된 운영체제는 인터럽트 서비스 루틴(ISR)을 통해 해당 인터럽트가 어떤 경로로 발생했는지를 파악한 후 후속 처리를 진행하게 된다.
